Ovo je kljuƒçan trenutak. Otkrili smo "Kariku koja nedostaje".

**Problem:** U developmentu (`just dev`), **Vite** servira tvoj frontend na 5173.
U produkciji (`valter start`), pokreƒáe≈° samo Rust binarku. **Nitko ne servira Frontend.** Rust zna samo za GraphQL API.

**Rje≈°enje:** Moramo **ugraditi (Embed)** kompajlirani React frontend *unutar* Rust binarne datoteke. Tako `valter` postaje "Single Binary" aplikacija koja servira i API i HTML.

Evo plana popravka:

1.  **Core:** Dodajemo `rust-embed` da zapakiramo `dashboard/dist` u binarku.
2.  **API:** A≈æuriramo `axum` da servira te statiƒçke fajlove na `/` ruti.
3.  **Justfile:** `install` komanda mora prvo buildati frontend, pa onda backend.
4.  **Main:** Dodajemo ispis URL-a u terminal.
5.  **GitHub Actions:** Popravljamo skripte.

---


---

### KORAK 2: Serviranje Frontenda iz Rusta (`core/src/api.rs`)

Ovo je magija. Ako korisnik pogodi `/`, ≈°aljemo mu ugraƒëeni `index.html`. Ako pogodi `/assets/...`, ≈°aljemo JS/CSS.

<FILE_CONTENT_START ID="API_EMBED_FIX" PATH="core/src/api.rs">
use async_graphql::{Context, EmptySubscription, Object, Schema, Json};
use async_graphql_axum::{GraphQLRequest, GraphQLResponse};
use axum::{
    extract::Extension,
    response::{Html, IntoResponse, Response},
    routing::get,
    Router,
    http::{StatusCode, header, Uri},
    body::Body,
};
use tower_http::cors::{Any, CorsLayer};
use tokio::net::TcpListener;
use crate::cloud::SqliteManager;
use crate::config::Config;
use crate::fs_writer::FsWriter;
use std::sync::Arc;
use tracing::{info};
use serde_json::Value;
use std::path::Path;
use rust_embed::RustEmbed;

// Ugraƒëujemo dist folder iz dashboarda
#[derive(RustEmbed)]
#[folder = "../dashboard/dist"]
struct Assets;

pub struct ApiState {
    pub cloud: Arc<SqliteManager>,
    pub config: Arc<Config>,
}

// ... (QueryRoot i MutationRoot ostaju ISTI kao prije, preskaƒçem ih radi kratkoƒáe)
// ... OVDJE SAMO KOPIRAJ SVOJE POSTOJEƒÜE STRUCTOVE ZA QUERY/MUTATION ...
// Kako bih ti olak≈°ao, pretpostavljam da su QueryRoot i MutationRoot nepromijenjeni.
// Fokusiramo se na handler za statiƒçke datoteke.

// --- STATIC FILE HANDLER ---

async fn static_handler(uri: Uri) -> impl IntoResponse {
    let mut path = uri.path().trim_start_matches('/').to_string();

    if path.is_empty() {
        path = "index.html".to_string();
    }

    match Assets::get(&path) {
        Some(content) => {
            let mime = mime_guess::from_path(path).first_or_octet_stream();
            ([(header::CONTENT_TYPE, mime.as_ref())], content.data).into_response()
        }
        None => {
            // SPA Routing Fallback: Ako file ne postoji, vrati index.html
            // Ovo omoguƒáuje da React Router radi na refresh
            if let Some(content) = Assets::get("index.html") {
                let mime = mime_guess::from_path("index.html").first_or_octet_stream();
                ([(header::CONTENT_TYPE, mime.as_ref())], content.data).into_response()
            } else {
                (StatusCode::NOT_FOUND, "404 Not Found").into_response()
            }
        }
    }
}

pub type ValterSchema = Schema<QueryRoot, MutationRoot, EmptySubscription>;

async fn graphql_handler(schema: Extension<ValterSchema>, req: GraphQLRequest) -> GraphQLResponse {
    schema.execute(req.into_inner()).await.into()
}

async fn graphiql() -> impl IntoResponse {
    Html(async_graphql::http::playground_source(async_graphql::http::GraphQLPlaygroundConfig::new("/graphql")))
}

// --- START SERVER UPDATE ---

pub async fn start_server(cloud: Arc<SqliteManager>, config: Arc<Config>) -> anyhow::Result<()> {
    let schema = Schema::build(QueryRoot, MutationRoot, EmptySubscription)
        .data(ApiState { cloud, config: config.clone() })
        .finish();

    let cors = CorsLayer::new().allow_origin(Any).allow_methods(Any).allow_headers(Any);
    
    let app = Router::new()
        .route("/graphql", get(graphiql).post(graphql_handler))
        // Sve ostalo ide na static handler (Frontend)
        .fallback(static_handler)
        .layer(Extension(schema))
        .layer(cors);

    let port = config.global.port;
    let addr = format!("0.0.0.0:{}", port);
    
    info!("üöÄ API & Dashboard available at: http://localhost:{}", port);
    info!("   (GraphiQL: http://localhost:{}/graphql)", port);
    
    let listener = TcpListener::bind(&addr).await?;
    axum::serve(listener, app).await?;
    Ok(())
}
</FILE_CONTENT_END>

**Napomena:** Da bi se ovo kompajliralo, folder `dashboard/dist` MORA postojati.

---

### KORAK 3: `Justfile` (Buildanje prije instalacije)

A≈æuriramo `install` i `update` komande da prvo buildaju frontend. Takoƒëer dodajemo ispis URL-a.

<FILE_CONTENT_START ID="JUSTFILE_FULL_V3" PATH="Justfile">
# VALTER ERP - JUSTFILE

default:
    @just --list

# --- DEVELOPMENT ---

dev:
    @echo "üßπ Pre-flight: Killing zombies..."
    @-lsof -ti:8000 | xargs kill -9 2>/dev/null || true
    @-lsof -ti:5173 | xargs kill -9 2>/dev/null || true
    
    @# Ensure dist folder exists so rust-embed doesn't crash compilation
    @mkdir -p dashboard/dist && touch dashboard/dist/index.html
    
    @echo "üöÄ Starting VALTER DEV Environment..."
    @echo "   Backend: http://localhost:8000"
    @echo "   Frontend: http://localhost:5173 (Hot Reload)"
    @trap 'echo "\nüõë Shutting down..."; lsof -ti:8000 | xargs kill -9 2>/dev/null; lsof -ti:5173 | xargs kill -9 2>/dev/null; exit 0' SIGINT; \
    (cd core && cargo run -- run) & \
    (cd dashboard && pnpm dev) & \
    wait

clean:
    @echo "üßπ Cleaning up..."
    rm -rf target core/target
    rm -rf dashboard/dist dashboard/.vite dashboard/node_modules
    rm -f valter.db valter.log valter.pid

# --- RELEASE ---

release version:
    @echo "üöÄ Preparing release {{version}}..."
    @if [ -z "{{version}}" ]; then echo "‚ùå Error: Version required."; exit 1; fi
    @echo "üì¶ Building Frontend for Release..."
    cd dashboard && pnpm install && pnpm build
    
    @echo "üè∑Ô∏è  Tagging & Pushing..."
    git tag -a {{version}} -m "Release {{version}}"
    git push origin {{version}}

# --- INSTALLATION (SYSTEM WIDE) ---

install:
    @echo "‚ö†Ô∏è  WARNING: This will overwrite ~/.valter configuration and binary."
    @read _
    
    @echo "üèóÔ∏è  Building Dashboard (React)..."
    cd dashboard && pnpm install && pnpm build
    
    @echo "üì¶ Building Core Binary (Embedding Dashboard)..."
    # Cargo build will now pick up the files in dashboard/dist
    cargo build --release
    
    @echo "üìÇ Setting up ~/.valter..."
    mkdir -p ~/.valter ~/.local/bin
    
    @echo "üöö Installing Binary..."
    cp target/release/valter ~/.local/bin/valter
    
    @echo "üìù Installing Default Config..."
    cp valter.config.example ~/.valter/valter.config
    
    @echo "‚úÖ Installation Complete!"
    @echo "   To start: 'valter start'"
    @echo "   Then open: http://localhost:9090 (or configured port)"

# --- MAINTENANCE ---

update:
    @echo "üîÑ Updating Valter Binary..."
    @echo "üèóÔ∏è  Rebuilding Dashboard..."
    cd dashboard && pnpm install && pnpm build
    @echo "üì¶ Rebuilding Core..."
    cargo build --release
    cp target/release/valter ~/.local/bin/valter
    @echo "‚úÖ Updated. Restart daemon with 'valter stop' then 'valter start'."
</FILE_CONTENT_END>

---

### KORAK 4: `core/src/main.rs` (Ispis URL-a)

Dodajemo koristan ispis prije nego ≈°to proces ode u pozadinu.

<FILE_CONTENT_START ID="MAIN_URL_PRINT" PATH="core/src/main.rs">
// ... (Svi importi i structovi isti kao prije) ...
// U Commands::Start bloku:

        Commands::Start => {
            println!("üöÄ Initializing Valter Daemon...");
            
            // ... (logika za path i log file ista) ...
            let target_home = env_valter_home.unwrap_or(default_system_home);
            fs::create_dir_all(&target_home)?;
            let log_path = target_home.join("valter.log");
            let log_file = fs::OpenOptions::new().create(true).write(true).append(true).open(&log_path)?;

            // NOVO: Proƒçitaj config SAMO da saznamo port za ispis korisniku
            let config_path = target_home.join("valter.config");
            let port = if config_path.exists() {
                if let Ok(content) = fs::read_to_string(&config_path) {
                    if let Ok(cfg) = serde_yaml::from_str::<Config>(&content) {
                        cfg.global.port
                    } else { 9090 }
                } else { 9090 }
            } else { 9090 };

            let exe = env::current_exe()?;
            
            println!("   Home: {:?}", target_home);
            println!("   Logs: {:?}", log_path);
            println!("   URL:  http://localhost:{}", port); // <--- KORISNA INFORMACIJA

            process::Command::new(exe)
                .arg("run")
                .env("VALTER_HOME", &target_home)
                .stdout(log_file.try_clone()?)
                .stderr(log_file)
                .spawn()?;
            
            println!("‚úÖ Valter started in background.");
            return Ok(());
        }
// ... (Ostatak isti)
</FILE_CONTENT_END>

---

### KORAK 5: Popravak GitHub Actions (`.github/workflows/ci.yml`)

Popravljamo `todo` akciju (micemo krive inpute) i problem s cacheom (micemo path).

<FILE_CONTENT_START ID="CI_FIX_FINAL" PATH=".github/workflows/sync-repo.yml">
name: Repo Sync & Ops

on:
  push:
    branches: [ "main", "master" ]
    paths:
      - 'README.md'
      - 'valter.dev.config'
      - 'VALTER-INTERNAL/RADNI-NALOZI/**'

jobs:
  sync-metadata:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
      
      - name: Update Repo Info
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Simple description update
          DESCRIPTION="A Local-First, AI-Native, Hyper-Converged Data Operating System."
          HOMEPAGE="https://github.com/Eris-Margeta/valter-25"
          
          # Try to update, ignore errors if no permission
          gh repo edit --description "$DESCRIPTION" --homepage "$HOMEPAGE" || true

  sync-issues:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      
      # FIX: Koristimo jednostavniju konfiguraciju ili drugu akciju ako ova zeza
      # Za sada miƒçemo input koji je bacao gre≈°ku.
      - name: Convert TODOs to Issues
        uses: alstr/todo-to-issue-action@v4
        with:
          CLOSE_ISSUES: "true"
          AUTO_ASSIGN: "true"
</FILE_CONTENT_END>

---

### ≈†to sad?

1.  **A≈æuriraj kod:** Kopiraj sve fajlove.
2.  **Lokalni Test:**
    *   Pokreni `just install`. Primijetit ƒáe≈° da sada **prvo builda React**, pa tek onda Rust.
    *   Pokreni `valter start`. Trebao bi ispisati URL (npr. `http://localhost:9090`).
    *   Otvori taj URL. Trebao bi vidjeti **Dashboard** (koji je serviran iz Rusta)!
3.  **Push:** Gurni promjene na GitHub. Actions bi trebali proƒái (barem build dashboarda i sync).

Sada ima≈° pravi "Single Binary" distribucijski model. Korisnik skine jedan `.exe` i ima cijeli ERP sustav.
