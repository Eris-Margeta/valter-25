Ovo je kompleksan set problema, ali rje≈°iv. Problem "Produkcija prikazuje Dev podatke" se dogaƒëa jer `pnpm build` nije ispravno prepoznao ENV varijable ili je ostao *cache*.

Problem "Address in use" i "Initializing" znaƒçi da se procesi ne gase ƒçisto i da frontend ne mo≈æe dohvatiti backend (CORS ili krivi port).

Rije≈°it ƒáemo sve ovo arhitekturalnim promjenama u `main.rs` (uvodimo **Reload Loop**) i popravkom frontenda.

Evo **CIJELIH** fajlova koje mora≈° zamijeniti.

### 1. `dashboard/src/api.ts` (Frontend Logic Fix)

Dodajemo logiranje da u konzoli browsera vidi≈° toƒçno kamo frontend "puca". Takoƒëer osiguravamo da produkcija koristi relativnu putanju.

<FILE_CONTENT_START ID="DASHBOARD_API_FIX" PATH="dashboard/src/api.ts">
// Detekcija okoline
const isDev = import.meta.env.DEV;

// U Devu (Vite 5173) gaƒëamo 8000.
// U Prod (Rust 9090) koristimo relativni path (isti host/port).
const BASE_URL = isDev ? 'http://localhost:8000' : '';
const GRAPHQL_URL = `${BASE_URL}/graphql`;

console.log(`[VALTER LINK] Mode: ${isDev ? 'DEV' : 'PROD'}`);
console.log(`[VALTER LINK] Connecting to: ${GRAPHQL_URL}`);

export async function graphqlRequest(query: string, variables: any = {}) {
  try {
    const res = await fetch(GRAPHQL_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query, variables })
    });
    
    if (!res.ok) {
      const txt = await res.text();
      console.error("[VALTER LINK] HTTP Error:", res.status, txt);
      throw new Error(`Server Error (${res.status})`);
    }

    const json = await res.json();
    if (json.errors) {
      console.warn("[VALTER LINK] GraphQL Error:", json.errors);
      throw new Error(json.errors[0].message);
    }
    return json.data;
  } catch (e) {
    console.error("[VALTER LINK] Network/Parse Error:", e);
    throw e;
  }
}

export const QUERIES = {
  GET_CONFIG: `
    query { 
      config
    }
  `,
  GET_CLOUD_DATA: `
    query($name: String!) { 
      cloudData(name: $name) 
    }
  `,
  GET_ISLAND_DATA: `
    query($name: String!) {
      islandData(name: $name)
    }
  `,
  GET_PENDING_ACTIONS: `
    query {
      pendingActions
    }
  `,
  ASK_ORACLE: `
    query($q: String!) {
      askOracle(question: $q)
    }
  `
};

export const MUTATIONS = {
  RESOLVE_ACTION: `
    mutation($id: String!, $choice: String!) {
      resolveAction(actionId: $id, choice: $choice)
    }
  `,
  UPDATE_ISLAND_FIELD: `
    mutation($type: String!, $name: String!, $key: String!, $value: String!) {
      updateIslandField(islandType: $type, islandName: $name, key: $key, value: $value)
    }
  `
};
</FILE_CONTENT_END>

---

### 2. `core/src/api.rs` (Graceful Shutdown)

Moramo omoguƒáiti `main.rs` da ugasi API server kada se config promijeni, bez da ubija cijeli proces. Dodajemo `shutdown_signal`.

<FILE_CONTENT_START ID="API_SHUTDOWN_FIX" PATH="core/src/api.rs">
use async_graphql::{Context, EmptySubscription, Object, Schema, Json};
use async_graphql_axum::{GraphQLRequest, GraphQLResponse};
use axum::{
    extract::Extension,
    response::{Html, IntoResponse},
    routing::get,
    Router,
    http::{StatusCode, header, Uri},
};
use tower_http::cors::{Any, CorsLayer};
use tokio::net::TcpListener;
use crate::cloud::SqliteManager;
use crate::config::Config;
use crate::fs_writer::FsWriter;
use std::sync::Arc;
use tracing::info;
use serde_json::Value;
use std::path::Path;
use rust_embed::RustEmbed;

#[derive(RustEmbed)]
#[folder = "../dashboard/dist"]
struct Assets;

pub struct ApiState {
    pub cloud: Arc<SqliteManager>,
    pub config: Arc<Config>,
}

// --- GRAPHQL ---
pub struct QueryRoot;

#[Object]
impl QueryRoot {
    async fn config(&self, ctx: &Context<'_>) -> Json<Config> {
        let state = ctx.data::<ApiState>().expect("ApiState missing");
        Json(state.config.as_ref().clone())
    }

    async fn cloud_data(&self, ctx: &Context<'_>, name: String) -> Json<Vec<Value>> {
        let state = ctx.data::<ApiState>().expect("ApiState missing");
        if !state.config.clouds.iter().any(|c| c.name == name) { return Json(vec![]); }
        state.cloud.fetch_all_dynamic(&name).map(Json).unwrap_or(Json(vec![]))
    }

    async fn island_data(&self, ctx: &Context<'_>, name: String) -> Json<Vec<Value>> {
        let state = ctx.data::<ApiState>().expect("ApiState missing");
        if !state.config.islands.iter().any(|i| i.name == name) { return Json(vec![]); }
        state.cloud.fetch_all_dynamic(&name).map(Json).unwrap_or(Json(vec![]))
    }

    async fn pending_actions(&self, ctx: &Context<'_>) -> Json<Vec<Value>> {
        let state = ctx.data::<ApiState>().expect("ApiState missing");
        state.cloud.fetch_pending_actions().map(Json).unwrap_or(Json(vec![]))
    }

    async fn ask_oracle(&self, ctx: &Context<'_>, question: String) -> String {
        let state = ctx.data::<ApiState>().expect("ApiState missing");
        
        // Context building (Simplified for brevity, logic remains same)
        let mut context_str = String::from("System Context:\n");
        for cloud in &state.config.clouds { context_str.push_str(&format!("Table: {}\n", cloud.name)); }

        let api_key = std::env::var("GEMINI_API_KEY").unwrap_or_default();
        if api_key.is_empty() { return "Error: GEMINI_API_KEY missing.".to_string(); }

        let client = reqwest::Client::new();
        let url = format!("https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key={}", api_key);
        let prompt = format!("Role: Valter Oracle.\nContext: {}\nQuery: {}", context_str, question);
        let body = serde_json::json!({ "contents": [{ "parts": [{"text": prompt}] }] });

        match client.post(&url).json(&body).send().await {
            Ok(res) => res.json::<Value>().await.ok()
                .and_then(|j| j["candidates"][0]["content"]["parts"][0]["text"].as_str().map(|s| s.to_string()))
                .unwrap_or("AI Parse Error".to_string()),
            Err(e) => format!("AI Error: {}", e)
        }
    }
}

pub struct MutationRoot;

#[Object]
impl MutationRoot {
    async fn update_island_field(&self, ctx: &Context<'_>, island_type: String, island_name: String, key: String, value: String) -> String {
        let state = ctx.data::<ApiState>().expect("ApiState missing");
        if let Ok(rows) = state.cloud.fetch_all_dynamic(&island_type) {
            if let Some(row) = rows.iter().find(|r| r.get("name").and_then(|v| v.as_str()) == Some(&island_name)) {
                if let Some(path_str) = row.get("path").and_then(|v| v.as_str()) {
                    let meta_path = Path::new(path_str).join("meta.yaml");
                    if FsWriter::update_yaml_field(&meta_path, &key, &value).is_ok() {
                        return "Success".to_string();
                    }
                }
            }
        }
        "Error".to_string()
    }

    async fn create_island(&self, ctx: &Context<'_>, island_type: String, name: String, initial_data: String) -> String {
        let state = ctx.data::<ApiState>().expect("ApiState missing");
        if let Some(def) = state.config.islands.iter().find(|i| i.name == island_type) {
             let parsed: std::collections::HashMap<String, String> = serde_json::from_str(&initial_data).unwrap_or_default();
             let data: Vec<_> = parsed.into_iter().collect();
             let root = def.root_path.replace("/*", "");
             if FsWriter::create_island(&root, &name, data).is_ok() { return "Created".to_string(); }
        }
        "Error".to_string()
    }

    async fn resolve_action(&self, ctx: &Context<'_>, action_id: String, choice: String) -> String {
        let state = ctx.data::<ApiState>().expect("ApiState missing");
        match choice.as_str() {
            "APPROVE" => state.cloud.approve_pending_creation(&action_id).map(|id| format!("Created: {}", id)).unwrap_or("Error".to_string()),
            "REJECT" => { let _ = state.cloud.reject_pending_action(&action_id); "Rejected".to_string() },
            _ => "Unknown".to_string()
        }
    }
}

pub type ValterSchema = Schema<QueryRoot, MutationRoot, EmptySubscription>;

async fn graphql_handler(schema: Extension<ValterSchema>, req: GraphQLRequest) -> GraphQLResponse {
    schema.execute(req.into_inner()).await.into()
}

async fn graphiql() -> impl IntoResponse {
    Html(async_graphql::http::playground_source(async_graphql::http::GraphQLPlaygroundConfig::new("/graphql")))
}

async fn static_handler(uri: Uri) -> impl IntoResponse {
    let mut path = uri.path().trim_start_matches('/').to_string();
    if path.is_empty() { path = "index.html".to_string(); }
    match Assets::get(&path) {
        Some(content) => {
            let mime = mime_guess::from_path(path).first_or_octet_stream();
            ([(header::CONTENT_TYPE, mime.as_ref())], content.data).into_response()
        }
        None => {
            if let Some(content) = Assets::get("index.html") {
                let mime = mime_guess::from_path("index.html").first_or_octet_stream();
                ([(header::CONTENT_TYPE, mime.as_ref())], content.data).into_response()
            } else { (StatusCode::NOT_FOUND, "404 Not Found").into_response() }
        }
    }
}

// FIX: Dodan 'mut shutdown_rx' za Hot Reload
pub async fn start_server(
    cloud: Arc<SqliteManager>, 
    config: Arc<Config>, 
    mut shutdown_rx: tokio::sync::broadcast::Receiver<()>
) -> anyhow::Result<()> {
    let schema = Schema::build(QueryRoot, MutationRoot, EmptySubscription)
        .data(ApiState { cloud, config: config.clone() })
        .finish();

    let cors = CorsLayer::new().allow_origin(Any).allow_methods(Any).allow_headers(Any);
    let app = Router::new()
        .route("/graphql", get(graphiql).post(graphql_handler))
        .fallback(static_handler)
        .layer(Extension(schema))
        .layer(cors);

    let port = config.global.port;
    let addr = format!("0.0.0.0:{}", port);
    
    info!("üöÄ API available at: http://localhost:{}", port);
    
    let listener = TcpListener::bind(&addr).await?;
    
    // Axum with graceful shutdown
    axum::serve(listener, app)
        .with_graceful_shutdown(async move {
            shutdown_rx.recv().await.ok();
            info!("API shutting down for reload...");
        })
        .await?;
        
    Ok(())
}
</FILE_CONTENT_END>

---

### 3. `core/src/main.rs` (The Grand Unification)

Ovdje implementiramo **Hot Reload Loop**, **Human Logs** i provjeru porta.

<FILE_CONTENT_START ID="MAIN_RELOAD_FIX" PATH="core/src/main.rs">
mod config;
mod watcher;
mod context_engine;
mod cloud;
mod api;
mod oracle;
mod processor;
mod aggregator;
mod fs_writer;

use clap::{Parser, Subcommand};
use config::Config;
use watcher::Watcher;
use cloud::SqliteManager;
use oracle::ToolGenerator;
use processor::EventProcessor;
use anyhow::Result;
use tracing::{info, error, warn};
use tokio::sync::{mpsc, broadcast};
use std::sync::Arc;
use std::path::{Path, PathBuf};
use std::env;
use std::fs;
use std::process;
use std::time::Duration;
use std::thread;
use nix::sys::signal::{self, Signal};
use nix::unistd::Pid;
use std::net::TcpListener; // Za provjeru porta

#[derive(Parser)]
#[command(name = "valter")]
#[command(about = "Valter ERP Daemon", long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Option<Commands>,
}

#[derive(Subcommand)]
enum Commands {
    Start,
    Stop,
    Run,
}

#[tokio::main]
async fn main() -> Result<()> {
    dotenv::dotenv().ok();
    let cli = Cli::parse();

    // --- SETUP PATHS ---
    let user_home = env::var("HOME").or_else(|_| env::var("USERPROFILE"))
        .unwrap_or_else(|_| ".".to_string());
    let default_system_home = PathBuf::from(user_home).join(".valter");
    let env_valter_home = env::var("VALTER_HOME").ok().map(PathBuf::from);
    let current_home = env_valter_home.clone().unwrap_or_else(|| PathBuf::from("."));
    
    // PID logic
    let pid_file_path = if let Some(ref path) = env_valter_home {
        path.join("valter.pid")
    } else if current_home.join("valter.dev.config").exists() {
        PathBuf::from("valter.pid")
    } else {
        default_system_home.join("valter.pid")
    };

    // --- COMMAND HANDLING ---
    match cli.command.unwrap_or(Commands::Run) {
        Commands::Stop => {
            return stop_daemon(&pid_file_path);
        }
        Commands::Start => {
            // Aggressive Cleanup
            if is_daemon_running(&pid_file_path) {
                println!("üîÑ Found running instance via PID. Stopping...");
                let _ = stop_daemon(&pid_file_path);
                thread::sleep(Duration::from_millis(1000));
            }

            // Production Paths
            let target_home = env_valter_home.unwrap_or(default_system_home);
            fs::create_dir_all(&target_home)?;
            
            // Check Port Availability BEFORE spawning
            let config_path = target_home.join("valter.config");
            let port = if config_path.exists() {
                if let Ok(c) = fs::read_to_string(&config_path) {
                    if let Ok(cfg) = serde_yaml::from_str::<Config>(&c) { cfg.global.port } else { 9090 }
                } else { 9090 }
            } else { 9090 };

            if is_port_in_use(port) {
                eprintln!("‚ùå Port {} is ALREADY in use by another process!", port);
                eprintln!("   Please identify and kill the zombie process:");
                eprintln!("   lsof -ti:{} | xargs kill -9", port);
                process::exit(1);
            }

            // Logs
            let log_path = target_home.join("valter.log");
            let log_file = fs::OpenOptions::new().create(true).write(true).append(true).open(&log_path)?;

            let exe = env::current_exe()?;
            
            println!("üöÄ Starting Valter Daemon...");
            println!("   Home: {:?}", target_home);
            println!("   Logs: {:?}", log_path);
            println!("   URL:  http://localhost:{}", port);

            process::Command::new(exe)
                .arg("run")
                .env("VALTER_HOME", &target_home)
                .stdout(log_file.try_clone()?)
                .stderr(log_file)
                .spawn()?;
            
            println!("‚úÖ Started successfully.");
            return Ok(());
        }
        Commands::Run => {
            // Logging Configuration (Human Readable Time)
            // If in system mode (ENV set), no ANSI. If dev, yes ANSI.
            let use_ansi = env::var("VALTER_HOME").is_err();
            
            // Custom formatter for "2026-01-06 16:30:00"
            let timer = tracing_subscriber::fmt::time::ChronoLocal::new("%Y-%m-%d %H:%M:%S".to_string());

            tracing_subscriber::fmt()
                .with_ansi(use_ansi)
                .with_timer(timer)
                .init();
            
            let pid = process::id();
            let _ = fs::write(&pid_file_path, pid.to_string());
            info!("PID: {} | Log Path: {:?}", pid, pid_file_path);
        }
    }

    // =========================================================
    // THE HOT RELOAD LOOP
    // =========================================================
    
    // Setup paths only once
    let valter_home = env::var("VALTER_HOME").unwrap_or_else(|_| ".".to_string());
    let home_path = PathBuf::from(&valter_home);
    let is_system_mode = valter_home != ".";

    loop {
        info!("üîÅ System Loop: Initializing...");

        // 1. Config Load
        let config_path = if is_system_mode && home_path.join("valter.config").exists() {
            home_path.join("valter.config")
        } else if PathBuf::from("valter.dev.config").exists() {
            PathBuf::from("valter.dev.config")
        } else if PathBuf::from("../valter.dev.config").exists() {
            PathBuf::from("../valter.dev.config")
        } else if PathBuf::from("valter.config").exists() {
            PathBuf::from("valter.config")
        } else {
            error!("CRITICAL: Config not found. Retrying in 5s...");
            thread::sleep(Duration::from_secs(5));
            continue;
        };

        let config = match Config::load(config_path.to_str().unwrap()) {
            Ok(c) => Arc::new(c),
            Err(e) => {
                error!("Config Syntax Error: {}. Retrying in 5s...", e);
                thread::sleep(Duration::from_secs(5));
                continue;
            }
        };

        // 2. Database
        let db_path = if is_system_mode { home_path.join("valter.db") } else { PathBuf::from("valter.db") };
        let cloud = match SqliteManager::new(db_path.to_str().unwrap()) {
            Ok(c) => Arc::new(c),
            Err(e) => { error!("DB Error: {}", e); return Err(e); }
        };
        if let Err(e) = cloud.init_schema(&config) { error!("Schema Error: {}", e); }

        // 3. Oracle
        if let Ok(tools) = ToolGenerator::generate_tools(&config) { let _ = serde_json::to_string(&tools); }

        // 4. CHANNELS for Shutdown
        let (shutdown_tx, _) = broadcast::channel(1);
        let (fs_tx, mut fs_rx) = mpsc::channel(100);

        // 5. API Task
        let cloud_clone = cloud.clone();
        let config_clone = config.clone();
        let api_rx = shutdown_tx.subscribe();
        
        let api_handle = tokio::spawn(async move {
            if let Err(e) = api::start_server(cloud_clone, config_clone, api_rx).await {
                error!("API Fatal: {}", e);
                process::exit(1);
            }
        });

        // 6. Processor & Watcher
        let processor = EventProcessor::new(cloud.clone(), config.clone());
        let watch_root = if is_system_mode { valter_home.clone() } else { ".".to_string() };
        
        info!("üëÅÔ∏è  Watching: {}", watch_root);
        processor.scan_existing_metadata(&watch_root);

        // Watcher runs in separate thread but sends to fs_rx
        // We need to keep the watcher alive
        let _watcher = match Watcher::new(&watch_root, fs_tx) {
            Ok(w) => w,
            Err(e) => { error!("Watcher failed: {}", e); return Err(e); }
        };

        info!("‚úÖ System Operational.");

        // 7. Event Loop (Blocks until Reload or Shutdown)
        let mut reload_requested = false;

        loop {
            tokio::select! {
                Some(event) = fs_rx.recv() => {
                    // Check if config changed
                    for path in &event.paths {
                        if path.ends_with("valter.config") || path.ends_with("valter.dev.config") {
                            info!("‚ôªÔ∏è  Configuration Changed! Reloading system...");
                            reload_requested = true;
                            break;
                        }
                    }
                    if reload_requested { break; }
                    
                    // Normal processing
                    processor.handle_event(event).await;
                }
                // Handle Ctrl+C if in foreground
                _ = tokio::signal::ctrl_c() => {
                    info!("üõë Shutdown signal received.");
                    let _ = shutdown_tx.send(());
                    let _ = fs::remove_file(&pid_file_path);
                    return Ok(());
                }
            }
        }

        // 8. Reload Logic
        if reload_requested {
            // Signal API to stop
            let _ = shutdown_tx.send(());
            // Wait for API to finish
            let _ = api_handle.await;
            info!("--- RELOADING CORE ---");
            // Loop restarts, creating new Cloud, new Schema, new API on same port.
        }
    }
}

// Helpers

fn is_port_in_use(port: u16) -> bool {
    TcpListener::bind(("0.0.0.0", port)).is_err()
}

fn is_daemon_running(pid_path: &Path) -> bool {
    if !pid_path.exists() { return false; }
    if let Ok(c) = fs::read_to_string(pid_path) {
        if let Ok(pid) = c.trim().parse::<i32>() {
            if signal::kill(Pid::from_raw(pid), None).is_ok() { return true; }
        }
    }
    let _ = fs::remove_file(pid_path);
    false
}

fn stop_daemon(pid_path: &Path) -> Result<()> {
    if !pid_path.exists() {
        println!("Valter is not running.");
        return Ok(());
    }
    let pid = fs::read_to_string(pid_path)?.trim().parse::<i32>()?;
    println!("Stopping PID {}...", pid);
    if signal::kill(Pid::from_raw(pid), Signal::SIGTERM).is_ok() {
        // Wait loop
        for _ in 0..10 {
            if signal::kill(Pid::from_raw(pid), None).is_err() { break; }
            thread::sleep(Duration::from_millis(500));
        }
        println!("Stopped.");
        let _ = fs::remove_file(pid_path);
    } else {
        println!("Failed/Already dead.");
        let _ = fs::remove_file(pid_path);
    }
    Ok(())
}
</FILE_CONTENT_END>

### ≈†to sad?

1.  **A≈æuriraj** `dashboard/src/api.ts` i `core/src/api.rs` i `core/src/main.rs`.
2.  **Zaustavi sve:** `lsof -ti:9090 | xargs kill -9`.
3.  `just install`.
4.  `valter start`.

Sada:
*   Logovi ƒáe biti ƒçitljivi (`YYYY-MM-DD...`).
*   Ako promijeni≈° `valter.config` u `~/.valter/`, vidjet ƒáe≈° u logu `‚ôªÔ∏è Configuration Changed! Reloading system...` i sustav ƒáe se osvje≈æiti bez ga≈°enja.
*   Frontend ƒáe raditi jer koristi relativne putanje u produkciji.
